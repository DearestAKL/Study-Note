## ET
客户端 + 服务端的纯C#双端框架，总体架构是一部分ECS，一部分OOP，一部分组件式编程，网络架构是高效的分布式架构+Actor模型内网通信机制。

## ILRuntime
纯C#的热更新方案。借助Mono.Cecil库获取DLL的PE信息以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解释执行虚拟机来执行DLL中的代码来实现热更新功能。

### ILRuntime优缺点
**优点**
-   支持跨域继承，泛型，新增类型
-   跨域调用性能强大
-   纯C#开发，不用写Lua
-   完善的VS Debug插件支持

**缺点**
-   跨域继承需要适配器（新版本ILRuntime已经支持自动生成跨域继承适配器），但是优秀的设计下需要跨域继承的情况寥寥无几
-   默认情况下，热更域中引用的非热更值类型强制装箱。在做了CLR自动分析绑定后将会重定向到展开的值类型，无装箱。此外在引用类型中作为字段存在的值类型会被强制装箱，无论处于热更域还是非热更域。
-   非System.Action/Fun类型的委托需要手动注册委托类型转换
-   纯计算方面性能弱于Lua
## 语言基础
### 引用类型与值类型

- **继承类型**: 值类型隐式继承自System.ValueType而且不能继承其他任何类型，引用类型继承自System.Object

- **内存分配**: 值类型在栈中分配内存，引用类型在堆中分配内存，引用中存放的是堆中存放的地址

- **存取速度**: 值类型存取快，引用类型比值类型存取慢

- **存储内容**: 值类型表示实际数据，引用类型表示指向存储在对内存中的数据的指针

- **释放机制**: 栈内存是自动释放的，堆内存是由.Net的GC来自动释放的

- **默认赋值**: 值类型不能为null，必须有一个确定的值，引用类型在被赋值前都为null

- **赋值内容**: 赋值值类型变量是赋值变量的值，引用类型相当于是赋值变量的地址
### GC算法

#### 垃圾回收算法
CLR的GC使用跟踪引用算法。只关心引用类型的变量，我们将所有引用类型的变量称为根。

 **GC标记阶段：**
 
暂停进程中所有线程，然后进入GC标记阶段。CLR遍历堆中所有的对象，将同步索引字段中的一位设为0，表示所有对象都要被删除。然后CLR检查所有的活动根,看它引用了那些对象。如果一个根包含了null，CLR就忽略它并检查下个根。任何根如果引用了堆上的对象，CLR会标记它，把同步块索引的位设为1。一个对象背标记后，CLR会检查那个对象中的根，标记它们引用的对象。如果发现对象已被标记，就不重新检查对象字段。避免循环引用而产生死循环。

**GC压缩阶段：**

CLR对堆中已经标记的对象进行压缩，使他们占用连续的内存空间。所有幸存对象在内存中紧挨在一起，恢复了引用的“局部化”，减少了应用程序的工作集，从而提升了访问这些对象时的性能。其次，可用空间也全都都是连续的，所以这个地址空间段得到了解放。压缩意味着托管堆解决了本机堆的空间碎片化问题。因为地址变化，所以CLR要从每个根减去所引用对象在内存中偏移的字节数。

#### 基于代的垃圾回收器
- 对象越新，生存周期越短。
- 对象越老，生存周期越长。
- 回收堆的一部分，速度快于回收整个堆。



### 字典的实现原理

**Hash算法**与 **Hash碰撞冲突解决算法**
字典的查找利用哈希碰撞

#### 哈希碰撞
**HashCode**
0x7FFFFFFF是16进制表示的最大正整型数，此处是为了忽略符号位，获取非负数哈希码

**原理：**
字典的查找利用哈希碰撞，根据key获取hashCode，然后hashCode与hash桶进行碰撞，获取碰撞到的槽位，根据槽位上的值确认元素所在位置。

**冲突：**
不同的key有可能碰撞到同一个槽位上，如：4%5=4和9%5=4，不同的键4,9都碰撞到了索引为4的槽上

**拉链法：**
将每一个元素视为一个单链表结点，如果该槽位只对应一个元素，则该单链表只有一个结点，碰撞到同一个槽位上的元素之间通过next指针建立联系，查找时如果链表不止一个结点，遍历该单链表即可

### 装箱和拆箱

#### 装箱
值类型转为引用类型的过程叫装箱
装箱流程
- 在堆内存中分配值类型各字段加类型对象指针，同步块索引所需的内存空间
- 值类型的所有字段复制到新分配堆内存中
- 返回该对象的地址，也就是说该对象的引用

#### 拆箱
引用类型转为值类型的过程叫拆箱，但如果变量为null或引用类型指向的不是期待值类型的已装箱实例，会抛出异常

将值类型变成引用类型，存储的位置发生变化，发生了装箱，而且为了拆箱，现在引用类型的存储模式也不仅仅是以上引用类型的存储模型了，值类型的类型也会进行相应的存储，以方便在拆箱时候，转换成相应装箱时的类型。尽可能减少值类型与引用类型之间的转换与隐转。
### 堆和栈
- 堆的空间是手动申请和释放，用关键字new来分配，栈的空间由操作系统自动分配和释放
- 堆空间大，相对自由，栈的空间有限

## 图形学
### 渲染流水线
#### 应用阶段
##### *数据加载到显存*
- 把渲染所需数据从硬盘（HDD）中加载到系统内存（RAM）中。然后再把数据加载到显卡的存储空间——显存（VRAM）中。
##### *设置渲染状态*
- 定义场景中网格是怎么样被渲染的，例如使用哪个顶点着色器/片元着色器，光源属性，材质等。
#####  *调用Draw Call*
- 准备好上述所有工作后，CPU调用一个渲染命令来告诉GPU，让GPU按照设置开始渲染。

#### 几何阶段

#####  *顶点着色器 *
- 坐标变换
- 把顶点坐标从模型空间转换到齐次裁剪空间
- 逐顶点光照
- 为后续阶段提供数据
#####  *曲面细分着色器 *
- 细分图元
#####  *几何着色器 *
- 逐图元着色操作或者生成更多图元
##### *裁剪*
- 将不在摄像机范围内的顶点裁剪掉，并剔除某些三角形的面片
#####  *屏幕映射 *
- 把每个图元的x和y转换到屏幕坐标系下

#### 光栅化阶段

#####  *三角形设置 *
- 计算三角形网格数据，输出为下一阶段做准备
#####  *三角形遍历 *
- 检测每个像素是否被一个三角形网络所覆盖，如果被覆盖的话就会生成一个片元
#####  *片元着色器 *
- 输入上一个阶段对顶点信息插值得到的结果，输出一个或者多个颜色值
#####  *逐片元操作 *
- 决定每个片元的可见性（深度测试与模板测试等），通过了所有测试就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，也就是混合。

#### 屏幕成像


## 网络协议
### [比较TCP与UDP](https://blog.csdn.net/Li_Ning_/article/details/52117463)
TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。

#### TCP
TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输

#### UDP
UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。

#### TCP与UDP区别总结
> 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
> 
> 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
> 
> 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
> 
> 4、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
> 
> 5、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
> 
> 6、TCP首部开销20字节;UDP的首部开销小，只有8个字节
> 
> 7、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

### [TCP的三次握手和四次挥手](https://hit-alibaba.github.io/interview/basic/network/TCP.html)
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。

-   第一次握手(SYN=1, seq=x):
    
    客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
    
    发送完毕后，客户端进入 `SYN_SEND` 状态。
    
-   第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):
    
    服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。
    
-   第三次握手(ACK=1，ACKnum=y+1)
    
    客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
    
    发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。
    

三次握手的过程的示意图如下：

![three-way-handshake](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作。

-   第一次挥手(FIN=1，seq=x)
    
    假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
    
    发送完毕后，客户端进入 `FIN_WAIT_1` 状态。
    
-   第二次挥手(ACK=1，ACKnum=x+1)
    
    服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
    
    发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。
    
-   第三次挥手(FIN=1，seq=y)
    
    服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
    
    发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。
    
-   第四次挥手(ACK=1，ACKnum=y+1)
    
    客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。
    
    服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。
    
    客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。
    

四次挥手的示意图如下：

![four-way-handshake](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)
### [实现可靠UDP传输](https://zhuanlan.zhihu.com/p/129218784)

首先，为了保证可靠性，我们需要在发送数据的时候添加**重传定时器**，来保证丢失的数据会被重传。重传的定时器可以定时回调发送重传的数据，也支持将接收到ACK的数据从定时器中取出。
### [KCP](https://zhuanlan.zhihu.com/p/112442341)
#### 概述
TCP保证数据准确交付，UDP保证数据快速到达，KCP则是两种协议的一个折中。

KCP的设计目标是为了解决在网络拥堵的情况下TCP传输速度慢的问题。

下面是来自于官网的介绍：

> KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据的发送方式，以 callback的方式提供给 KCP。连时钟都需要外部传递进来，内部不会有任何一次系统调用。  
> TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。

KCP力求在保证可靠性的情况下提高传输速度。

KCP没有规定下层传输协议，但通常使用UDP来实现，至于原因，非常有必要说明，如果不清楚，就不能够真正地了解KCP。